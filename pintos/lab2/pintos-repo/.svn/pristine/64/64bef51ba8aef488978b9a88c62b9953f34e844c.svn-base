#include "userprog/syscall.h"
//1518886046250407618
#include <stdio.h>
#include <syscall-nr.h>
#include "threads/interrupt.h"
#include "threads/thread.h"
#include "threads/vaddr.h"
#include "threads/synch.h"
#include "filesys/file.h"

static void syscall_handler (struct intr_frame *);
static void syscall_write (struct intr_frame *);
static void syscall_exec (struct intr_frame *);
bool copy_data(uint8_t *udst, uint8_t *src, int size);
struct lock file_lock;


void
syscall_init (void) 
{
  
  
  intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
  lock_init(&file_lock);
}

static void
syscall_handler (struct intr_frame *f UNUSED) 
{
	int *sp = f->esp;
	switch(*sp)	{	
		case SYS_EXIT:
			thread_current()->exit_status = 0;
			thread_exit();
			//printf ("1write call!\n");
			break;
		case SYS_HALT:
			//printf ("2write call!\n");
			power_off();
			break;
		case SYS_EXEC:
			//printf ("3write call!\n");
		       syscall_exec(f);
			break;
		case SYS_WAIT:
			//printf ("4write call!\n");
			break;
		case SYS_CREATE:
		        syscall_create(f);
			break;
		case SYS_REMOVE:
		  syscall_remove(f);
			//printf ("6write call!\n");
			break;
		case SYS_OPEN:
		        syscall_open(f);
			break;
		case SYS_FILESIZE:
		//	printf ("8write call!\n");
		  syscall_filesize(f);
			break;
		case SYS_READ:
		  syscall_read(f);
		//	printf ("9write call!\n");
			break;
		case SYS_WRITE:
			syscall_write(f);
			// printf ("1111write call!\n"); 
			break;
		case SYS_SEEK:
		  syscall_seek(f);
			//printf ("10write call!\n");
			break;
		case SYS_TELL:
		  syscall_tell(f);
			//printf ("11write call!\n");
			break;
		case SYS_CLOSE:
		  syscall_close(f);
			//printf ("12write call!\n");
			break;
		default:
			//printf ("13system call!\n");
			thread_current()->exit_status =-1;
			thread_exit ();
	}
}
static void
syscall_write(struct intr_frame *f){
	int *sp = f->esp;
	int fd= *(sp+1);
	char *buffer = (char *)(*(sp+2));
	int size = *(sp+3);
	//printf("hmmmm.\n");
	struct thread *t = thread_current();
	//TODO check user's buffer. can't trust it.
	if(fd==1){
		f->eax = size;
		while(size>100){
			putbuf(buffer,100);
			buffer=buffer+100;
			size=size-100;

		}
		putbuf(buffer,size);
	}
	else if(t->files[fd] != NULL){
		f->eax = file_write(t->files[fd],buffer, size);
	}
	else{
		f->eax =-1;
	}
}



 void
syscall_read(struct intr_frame *f){
        int *sp = f->esp;
	int fd= *(sp+1);
	char *buffer = (char *)(*(sp+2));
	int size = *(sp+3);
	struct thread *t = thread_current();
	int i=0;
	if(fd==0){
		f->eax = size;
		while(size>0){
			buffer[i]=input_getc();
			//buffer=buffer+100;
			size=size-1;
			i++;
		}
		/* getch(buffer,size); */
	}
	else if(t->files[fd] != NULL){
		f->eax = file_read(t->files[fd],buffer, size);
	}
	else{
		f->eax =-1;
	}
}

void syscall_remove(struct intr_frame *f){  
  int *sp= f->esp;
  char *filename=(char *)(*(sp+1));
  if(!filesys_remove(filename))f->eax=-1;
     else f->eax=1;
     
}
 void
syscall_tell(struct intr_frame *f){
        int *sp = f->esp;
	int fd= *(sp+1);
	 struct thread *th= thread_current();
	 file_tell(th->files[fd]);
 }

void syscall_create(struct intr_frame *f){  
  int *sp= f->esp;
  char *filename=(char *)(*(sp+1));
  int size=*(sp+2);
  lock_acquire(&file_lock);
  if(!filesys_create(filename,size)==true){
    f->eax=-1;
    lock_release(&file_lock);
    printf("Are we here.\n");
  }
  else f->eax=1; 
    lock_release(&file_lock);
    printf("create succesful\n");
}
static void
syscall_exec(struct intr_frame *f){
  int *sp=f->esp;
  char *filename=(char *)(*(sp+1));
  f->eax=process_execute(filename);
  
}
void syscall_seek(struct intr_frame *f){  
  int *sp= f->esp;
  int fd=*(sp+1);
  int position=*(sp+2);
  struct thread *th= thread_current();
  file_seek(th->files[fd],position);
    }
	  
void syscall_close(struct intr_frame *f){  
  int *sp= f->esp;
  int fd=*(sp+1);
  struct thread *th= thread_current();
  file_close(th->files[fd]);
}

void syscall_filesize(struct intr_frame *f){  
  int *sp= f->esp;
  int fd=*(sp+1);
  f->eax=-1;
  struct thread *th= thread_current();
  f->eax= file_length(th->files[fd]);
}
int syscall_open(struct intr_frame *f){
   int *sp=f->esp;
   int index=-1;
   char *filename=(char *)(*(sp+1));

   if(filename==NULL)thread_exit();
   lock_acquire(&file_lock);
  
   struct file *file1=filesys_open(filename);
   if(file1==NULL) return -1;
   struct thread *th= thread_current();
   printf("filename1: %s \n",filename);   
   index=2;
   while(th->files[index]!=NULL){
     index++;
   }
   th->files[index]=file1;
   lock_release(&file_lock);
   printf("Index: %d \n",index);  
   return index;
   
}



static void
syscall_exit(struct intr_frame *f){
	f->eax=1;
	printf("%s: exit(%d)\n", thread_name(),f->error_code);
	thread_exit();

}


/* Reads a byte at user virtual address UADDR.
   UADDR must be below PHYS_BASE.
   Returns the byte value if successful, -1 if a segfault
   occurred. */

static bool
check_pointer(uint8_t *userpointer,int size){
  if(((int)userpointer)<PHYS_BASE &&
     ((int)userpointer+size)<PHYS_BASE)
  return true;
  else return false;

}

static int
get_user (const uint8_t *uaddr)
{
  ASSERT((int)uaddr<PHYS_BASE);
  int result;
  asm ("movl $1f, %0; movzbl %1, %0; 1:"
       : "=&a" (result) : "m" (*uaddr));
  return result;
}
 
/* Writes BYTE to user address UDST.
   UDST must be below PHYS_BASE.
   Returns true if successful, false if a segfault occurred. */
static bool
put_user (uint8_t *udst, uint8_t byte)
{
  
  ASSERT((int)udst<PHYS_BASE);
  int error_code;
  asm ("movl $1f, %0; movb %b2, %1; 1:"
       : "=&a" (error_code), "=m" (*udst) : "q" (byte));
  return error_code != -1;
}

bool copy_data(uint8_t *udst, uint8_t *src, int size)
{
  int i =0;
  for(;i<size;i++){
    if(put_user(udst+i,src+i)==false)
      return false;
  }
  return true;
}
